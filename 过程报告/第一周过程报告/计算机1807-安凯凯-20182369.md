第一次过程报告
==
<p align="center">计1807-安凯凯-20182369<br></p>

1.Github的使用
--
实话说，之前我并没怎么使用过GitHub这个平台，只是在几个月前为了找一个关于五子棋的开源代码而注册了账户，所以对于这种方式的课程设计，既新颖又具有挑战。<br>
目前来说根据学长的讲解PPT以及网上讲的一一些方法，目前已经能够熟悉相关的操作并且正在尝试将本地的仓库与项目建立联系，以此方便项目进展情况的及时展示。

2.符号表的设计
--

目前和团队成员已经共同商议好符号表内的主体框架，目前正在已经完成的包括符号表主表SYNBL，数组表AINFL，结构表RINFL，类型表以及函数表，目前的打算是先将框架拉起来，然后开始不断地填充，以免开始的时候过于庞大导致不能按期完成。<br>
当然，由于我负责的部分是语义分析，所以目前我的主要工作注意在语义分析的四元式生成，但是因为要等到前面词法与语法分析完成对符号表的基本填充后，我才能够去实现语义分析的关于类型检查、重定义以及作用域等问题。


3.语义分析之四元式生成
--
从张老师的动员会当中，我深受启发，经过我们团队的商议我们决定采用从一个简单的文法开始先将一个单独文法的编译器前端完成再进行填充。所以目前关于语义分析我完成了对表达式文法的四元式生成。
文法如下：<br>
`E->EW0T|T` <br>
`T->TW1F|F` <br>
`F->I|(E)` <br>
目前已经能够完成对形如`(a+b)*c-d/(e-f)`这种表达式的四元式生成。<br>
当然，由于这个文法比较简单，所以生成四元式也比较的容易，通过对临时变量的生成以及增加语义动作即可。
然而当我完成的时候我才意识到我忽略了一个极大的问题：<br>
1.首先，对于文法中的符号的形式有很大要求，一方面在后期实现时候终结符与非终结符不可能只有单独一个字母存在，另一方面，关于用户定义变量的访问与存储也有很大的限制。<br>
对此，我们经过商量后，决定在词法与语法分析阶段由队友们将其类型全部改为string类进行存储，同时用vector/list容器进行封装，以便后期我在整合的时候可以直接通过TOKEN序列的内容来对语义栈进行操作，当然关于语义栈和当前符号我也需要将其相应的改为string类<br>
2.其次，因为我们是从一个非常简单的文法开始实现的，所以我们在前期对于文法的考虑就比较少。但是当我完成生成四元式这一部分以后，我发现问题来了：我在调用LL1分析表中的产生式的时候，我该选择哪一部分去实现对应的语句文法呢？就比如当我语句丰富到赋值、表达式、if-else等等之后，我如何从众多语句中选出我读到的当前符中的文法呢？<br>
所以我们就在思考这个问题，最后我们决定与张老师进行一次线上的交流，所以我们的工作任务有增加了对整体文法的设计。


4.文法的设计
--
正如前文所言，因为我们目前实现的文法比较简单，所以我们的语法分析及语义分析考虑的比较少。对于上述的问题，经过与张老师的讨论以后，我们了解到了整个编译器的文法应该是一整套下来的，然后因为我们用的是LL1分析方法，所以这张大的分析表是必须要建立出来的，故而，如果能够实现这一步，那么我们的语法/语义分析遇到的问题也就迎刃而解了。同时我们也在想是否可以将LL1分析方法和递归下降子程序方法结合起来，对于不同的文法结合实际采用不同的方法。<br>
因为目前我们设计的文法还在不断地改进与扩充，并且不能很好地满足LL1分析方法，所以在这里我就不做过多的展示，仅仅展示部分语义分析的结果以及代码。<br>
接下来我的工作重心会建立在四元式的生成与TOKEN流之间的建立，以及打通与符号表的互动这些任务，当然在文法定下来之后我们还会有一个很艰巨的任务去商讨———语义动作的定义与插入问题。

```cpp
while (X != '$')
    {   //当栈顶元素非$时
		a = input[index];
		if(a=='+'||a=='-'||a=='*'||a=='/'||a=='('||a==')'||a=='$')
            a=a;
        else
        {
            s=a;
            a='i';
        }
		//a是当前input串指针指向的元素
		if(X=='1'||X=='2'||X=='3'||X=='4')
        {
            string opr1,opr2;
            opr2=SEM.top();
            SEM.pop();
            opr1=SEM.top();
            SEM.pop();
            if(X=='1')
            {
                cout<<"(+,"<<opr1<<','<<opr2<<",t"<<count<<')'<<endl;

            }
            else if(X=='2')
            {
                cout<<"(-,"<<opr1<<','<<opr2<<",t"<<count<<')'<<endl;

            }
            else if(X=='3')
            {
                cout<<"(*,"<<opr1<<','<<opr2<<",t"<<count<<')'<<endl;

            }
            else
            {
                cout<<"(/,"<<opr1<<','<<opr2<<",t"<<count<<')'<<endl;
            }
            string  temp="t";
            temp=temp+count;
            SEM.push(temp);
            count++;
            Stack.pop();
        }
        else
        {
            x = notTerSym[X];
            //x对应的预测表达式的一维坐标  可能出现在栈顶的元素 非终结符+非首位终结符
            y = terSym[a];
            //a对应的预测表达式的二维坐标 终结符

            if(Analy[x][y].empty())
            {//预测分析表中为空
                cout<<x<<y<<endl;
                cout <<"1匹配输入串中第"<<index+1<<"个字符'"<<a<<"'时发生错误" << endl;
                break;
            }
            else
            {//在预测分析表中找到了匹配的产生式
                //cout << "压栈替代符" << X << "->" << Analy[x][y] << endl;
                Stack.pop();
                if (Analy[x][y] == "#") {}
                //不需要压栈Stack
                else if(Analy[x][y]=="5")
                {
                    SEM.push(s);
                }
                else
                {
                    for (std::size_t  i=0;i<Analy[x][y].length();i++)
                    {//将分析表对应内容压栈
                        Stack.push(Analy[x][y][i]);
                    }
                }
                if(NEXT[x][y]=="N")
                    index++;
                else if(NEXT[x][y]=="P")
                    index=index;
                else
                {
                    cout <<"2匹配输入串中第"<<index+1<<"个字符'"<<a<<"'时发生错误" << endl;
                    break;
                }

            }
        }
		X = Stack.top();//X重新赋值为栈顶元素
	}
  ```


